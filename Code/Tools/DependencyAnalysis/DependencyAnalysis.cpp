#include <Foundation/Application/Application.h>
#include <Foundation/CodeUtils/Tokenizer.h>
#include <Foundation/Configuration/Startup.h>
#include <Foundation/Containers/HashSet.h>
#include <Foundation/Containers/HashTable.h>
#include <Foundation/Containers/Map.h>
#include <Foundation/Containers/Set.h>
#include <Foundation/IO/FileSystem/DataDirTypeFolder.h>
#include <Foundation/IO/FileSystem/FileReader.h>
#include <Foundation/IO/FileSystem/FileSystem.h>
#include <Foundation/IO/JSONReader.h>
#include <Foundation/Logging/ConsoleWriter.h>
#include <Foundation/Logging/HTMLWriter.h>
#include <Foundation/Logging/Log.h>
#include <Foundation/Logging/VisualStudioWriter.h>
#include <Foundation/Memory/LinearAllocator.h>
#include <Foundation/Strings/PathUtils.h>
#include <Foundation/Strings/String.h>
#include <Foundation/Strings/StringBuilder.h>
#include <Foundation/System/SystemInformation.h>
#include <Foundation/Threading/TaskSystem.h>
#include <Foundation/Types/UniquePtr.h>

class nsDependencyAnalysisApp;


bool g_bVerbose = false;

namespace
{
  using DependencyListType = nsHashSet<nsString>;

  struct CompilationUnitContext
  {
    DependencyListType m_dependencies;
    nsDynamicArray<nsString> m_IncludeDirectories;
    nsHashTable<nsString, nsString> m_includeCache;
  };
  using CompilationUnitListType = nsHashTable<nsString, CompilationUnitContext>;

  NS_ALWAYS_INLINE void SkipWhitespace(nsToken& ref_token, nsUInt32& i, const nsDeque<nsToken>& tokens)
  {
    while (ref_token.m_iType == nsTokenType::Whitespace)
    {
      ref_token = tokens[++i];
    }
  }

  NS_ALWAYS_INLINE void SkipLine(nsToken& ref_token, nsUInt32& i, const nsDeque<nsToken>& tokens)
  {
    while (ref_token.m_iType != nsTokenType::Newline && ref_token.m_iType != nsTokenType::EndOfFile)
    {
      ref_token = tokens[++i];
    }
  }

  // Json parser for command_line.json files generated by cmake
  class CompileCommandsParser : public nsJSONParser
  {
  public:
    struct CompileCommand
    {
      nsString command;
      nsString file;
    };

    void Initialize(nsStreamReader& inout_stream)
    {
      SetInputStream(inout_stream);
    }

    nsResult GetNextCommand(CompileCommand& out_command)
    {
      while (!m_bObjectOpen)
      {
        if (!ContinueParsing())
        {
          return NS_FAILURE;
        }
      }

      while (m_bObjectOpen)
      {
        if (!ContinueParsing())
        {
          return NS_FAILURE;
        }
      }

      out_command = m_Command;
      return NS_SUCCESS;
    }

  private:
    // Inherited via nsJSONParser
    virtual bool OnVariable(nsStringView sVarName) override
    {
      bool needed = false;

      if (sVarName == "file")
      {
        needed = true;
        m_pNextVar = &m_Command.file;
      }
      else if (sVarName == "command")
      {
        needed = true;
        m_pNextVar = &m_Command.command;
      }

      if (!needed && sVarName != "directory" && sVarName != "output")
      {
        nsStringBuilder fmt;
        fmt.SetFormat("Unknown variable '{0}'", sVarName);
        ParsingError(fmt.GetView(), false);
      }
      return needed;
    }

    virtual void OnReadValue(nsStringView sValue) override
    {
      if (m_pNextVar == nullptr)
      {
        ParsingError("Unexpected value", true);
        return;
      }

      *m_pNextVar = sValue;
      m_pNextVar = nullptr;
    }

    virtual void OnReadValue(double fValue) override
    {
    }

    virtual void OnReadValue(bool bValue) override
    {
    }

    virtual void OnReadValueNULL() override
    {
    }

    virtual void OnBeginObject() override
    {
      if (!m_bOuterArrayOpen || m_bObjectOpen)
      {
        ParsingError("Unexpected object begin", true);
        return;
      }

      m_bObjectOpen = true;
      m_Command = {};
    }

    virtual void OnEndObject() override
    {
      if (!m_bObjectOpen)
      {
        ParsingError("Unexpected object end", true);
        return;
      }
      m_bObjectOpen = false;
    }

    virtual void OnBeginArray() override
    {
      if (!m_bOuterArrayOpen)
      {
        m_bOuterArrayOpen = true;
      }
      else
      {
        ParsingError("Unexpected array begin", true);
      }
    }

    virtual void OnEndArray() override
    {
      if (m_bOuterArrayOpen)
      {
        m_bOuterArrayOpen = false;
      }
      else
      {
        ParsingError("Unexpected array end", true);
      }
    }

    bool m_bOuterArrayOpen = false;
    bool m_bObjectOpen = false;
    nsString* m_pNextVar = nullptr;
    CompileCommand m_Command;
  };

  // nsOSFile::ExistsFile is quite slow, cache the results thread local to avoid lock contetion
  struct ExistsFileCache
  {
    static thread_local nsHashTable<nsString, bool> m_ExistsFileCache;

    static bool ExistsFile(nsStringView sFile)
    {
      bool existedAlready = false;
      bool returnValue = false;
      {
        bool& result = m_ExistsFileCache.FindOrAdd(sFile, &existedAlready);
        if (!existedAlready)
        {
          result = nsOSFile::ExistsFile(sFile);
        }
        returnValue = result;
      }
      return returnValue;
    }
  };

  thread_local nsHashTable<nsString, bool> ExistsFileCache::m_ExistsFileCache;

  // Task to parse a single header file
  // stores the results in the task, need to be extracted after finish using MoveOutDependencies
  class ParseHeaderFileTask : public nsTask
  {
  public:
    ParseHeaderFileTask()
    {
      ConfigureTask("ParseHeaderFileTask", nsTaskNesting::Maybe);
    }

    void Initialize(nsStringView sPath)
    {
      m_sPath = sPath;
    }

    virtual void Execute() override;

    nsStringView GetPath() const { return m_sPath; }
    nsHashSet<nsString>&& MoveOutDependencies() { return std::move(m_Dependencies); }

  private:
    nsString m_sPath;
    nsHashSet<nsString> m_Dependencies;
    nsTaskGroupID m_TaskGroup;
  };

  // Task to collect the dependencies of a single compilation unit
  // Might need to run multiple times (call HasWorkLeft to know if it needs to be executed again)
  // Needs to spawn other tasks when HasWorkLeft returns true: see ScheduleRemainingWork
  class CollectDependenciesTask : public nsTask
  {
  public:
    CollectDependenciesTask()
    {
      ConfigureTask("CollectDependenciesTask", nsTaskNesting::Maybe);
    }

    void Initialize(nsStringView sPath, CompilationUnitContext& ref_context, nsDependencyAnalysisApp& ref_app)
    {
      m_sPath = sPath;
      m_pContext = &ref_context;
      m_pApp = &ref_app;
    }

    void OnParsingFinished(nsTaskGroupID taskGroupID);

    virtual void Execute() override;

    bool HasWorkLeft() const { return m_LeftoverFiles.GetCount() > 0; }

    void ScheduleRemainingWork();

  private:
    nsStringView m_sPath;
    CompilationUnitContext* m_pContext = nullptr;
    nsDependencyAnalysisApp* m_pApp = nullptr;
    nsDynamicArray<nsSharedPtr<ParseHeaderFileTask>> m_ParseTasks;
    nsDynamicArray<nsString> m_LeftoverFiles;
    nsTaskGroupID m_ParseTaskGroup;
  };
} // namespace

/*
 * This application finds all dependencies of a given compile setup.
 *
 * Currently requires a compile_commands.json generated with cmake targeting the clang compiler
 *
 * Basic flow
 * - Parse the compile_command.json to find all .cpp files (compilation units)
 * - Parse each compilation unit, and find all headers it includes
 * - Parse all found headers and note their dependencies (storing only the unresolved paths)
 * - For each compilation unit resolve all dependencies by doing a breadth first search in parallel
 *   + Whenever we encounter a header file we have not seen yet, we need to parse it
 * - Write out the results into a json file. For each compilation units all header dependencies will be listed.
 */
class nsDependencyAnalysisApp : public nsApplication
{
private:
  friend CollectDependenciesTask;

  nsString m_sCompileCommandsPath;
  bool m_bHadErrors;
  bool m_bHadSeriousWarnings;
  bool m_bHadWarnings;
  nsDynamicArray<nsString> m_IgnorePatterns;
  nsString m_sOutputPath;

  CompilationUnitListType m_CompilationUnits;
  nsMutex m_HeaderDependenciesMutex;
  nsHashTable<nsString, DependencyListType> m_HeaderDependencies;

  nsMutex m_HeaderParsingScheduledMutex;
  nsHashSet<nsString> m_HeaderParsingScheduled;

public:
  using SUPER = nsApplication;

  nsDependencyAnalysisApp()
    : nsApplication("DependencyAnalysis")
  {
    m_bHadErrors = false;
    m_bHadSeriousWarnings = false;
    m_bHadWarnings = false;
  }

  /// Makes sure the apps return value reflects whether there were any errors or warnings
  static void LogInspector(const nsLoggingEventData& eventData)
  {
    nsDependencyAnalysisApp* app = (nsDependencyAnalysisApp*)nsApplication::GetApplicationInstance();

    switch (eventData.m_EventType)
    {
      case nsLogMsgType::ErrorMsg:
        app->m_bHadErrors = true;
        break;
      case nsLogMsgType::SeriousWarningMsg:
        app->m_bHadSeriousWarnings = true;
        break;
      case nsLogMsgType::WarningMsg:
        app->m_bHadWarnings = true;
        break;

      default:
        break;
    }
  }


  nsResult ParseArray(const nsVariant& value, nsHashSet<nsString>& ref_dst)
  {
    if (!value.CanConvertTo<nsVariantArray>())
    {
      nsLog::Error("Expected array");
      return NS_FAILURE;
    }
    auto a = value.Get<nsVariantArray>();
    const auto arraySize = a.GetCount();
    for (nsUInt32 i = 0; i < arraySize; i++)
    {
      auto& el = a[i];
      if (!el.CanConvertTo<nsString>())
      {
        nsLog::Error("Value {0} at index {1} can not be converted to a string. Expected array of strings.", el, i);
        return NS_FAILURE;
      }
      nsStringBuilder file = el.Get<nsString>();
      file.ToLower();
      ref_dst.Insert(file);
    }
    return NS_SUCCESS;
  }

  virtual void AfterCoreSystemsStartup() override
  {
    nsGlobalLog::AddLogWriter(nsLogWriter::Console::LogMessageHandler);
    nsGlobalLog::AddLogWriter(nsLogWriter::VisualStudio::LogMessageHandler);
    nsGlobalLog::AddLogWriter(LogInspector);


    nsSystemInformation info = nsSystemInformation::Get();
    const nsInt32 iCpuCores = info.GetCPUCoreCount();
    nsTaskSystem::SetWorkerThreadCount(iCpuCores);

    if (GetArgumentCount() < 2)
    {
      nsLog::Info("DependencyAnalysis.exe [options] path/to/compile_commands.json");
      nsLog::Info("");
      nsLog::Info("-i [pattern] --ignorePattern [pattern]    ignore all cpp/h files containing this pattern");
      nsLog::Info("-v           --verbose                    enable verbose logging");
      nsLog::Info("-o [path]    --output [path]              path to the output json file");
      nsLog::Info("");

      nsLog::Error("No command line arguments given.");
      return;
    }

    // Add the empty data directory to access files via absolute paths
    nsFileSystem::AddDataDirectory("", "App", ":", nsFileSystem::AllowWrites).IgnoreResult();

    // pass the absolute path to the directory that should be scanned as the first parameter to this application
    nsStringBuilder sCompileCommandsPath;

    auto numArgs = GetArgumentCount();
    auto shortIgnore = nsStringView("-i");
    auto longIgnore = nsStringView("--ignorePattern");
    auto shortVerbose = nsStringView("-v");
    auto longVerbose = nsStringView("--verbose");
    auto shortOutput = nsStringView("-o");
    auto longOutput = nsStringView("--output");
    for (nsUInt32 argi = 1; argi < numArgs; argi++)
    {
      auto arg = nsStringView(GetArgument(argi));
      if (arg == shortIgnore || arg == longIgnore)
      {
        if (numArgs <= argi + 1)
        {
          nsLog::Error("Missing path for {0}", arg);
          return;
        }
        nsStringBuilder ignorePattern = GetArgument(argi + 1);
        if (ignorePattern == shortIgnore || ignorePattern == longIgnore || ignorePattern == shortIgnore || ignorePattern == longIgnore || ignorePattern == shortOutput || ignorePattern == longOutput)
        {
          nsLog::Error("Missing path for {0} found {1} instead", arg, ignorePattern.GetView());
          return;
        }
        argi++;
        ignorePattern.MakeCleanPath();
        m_IgnorePatterns.PushBack(ignorePattern);
      }
      else if (arg == shortVerbose || arg == longVerbose)
      {
        g_bVerbose = true;
      }
      else if (arg == shortOutput || arg == longOutput)
      {
        if (!m_sOutputPath.IsEmpty())
        {
          nsLog::Error("Output path given multiple times");
          return;
        }
        if (numArgs <= argi + 1)
        {
          nsLog::Error("Missing path for {0}", arg);
          return;
        }
        nsStringBuilder outputPath = GetArgument(argi + 1);
        if (outputPath == shortIgnore || outputPath == longIgnore || outputPath == shortIgnore || outputPath == longIgnore || outputPath == shortOutput || outputPath == longOutput)
        {
          nsLog::Error("Missing path for {0} found {1} instead", arg, outputPath.GetView());
          return;
        }
        if (!outputPath.IsAbsolutePath())
        {
          outputPath = nsOSFile::GetCurrentWorkingDirectory();
          outputPath.AppendPath(GetArgument(argi + 1));
        }
        outputPath.MakeCleanPath();
        argi++;
        m_sOutputPath = outputPath;
      }
      else
      {
        if (sCompileCommandsPath.IsEmpty())
        {
          sCompileCommandsPath = arg;
          sCompileCommandsPath.MakeCleanPath();
        }
        else
        {
          nsLog::Error("Currently only one directory is supported for searching. Did you forget -i|--includeDir? {0}", arg);
        }
      }
    }

    if (!nsPathUtils::IsAbsolutePath(sCompileCommandsPath.GetData()))
      nsLog::Error("The given path is not absolute: '{0}'", sCompileCommandsPath);

    m_sCompileCommandsPath = sCompileCommandsPath;

    if (m_sOutputPath.IsEmpty())
    {
      nsLog::Error("No output path given. Use -o or --output");
    }
  }

  virtual void BeforeCoreSystemsShutdown() override
  {
    SetReturnCode(0);

    nsGlobalLog::RemoveLogWriter(LogInspector);
    nsGlobalLog::RemoveLogWriter(nsLogWriter::Console::LogMessageHandler);
    nsGlobalLog::RemoveLogWriter(nsLogWriter::VisualStudio::LogMessageHandler);
  }

  static nsResult ReadEntireFile(nsStringView sFile, nsStringBuilder& out_sContents)
  {
    out_sContents.Clear();

    nsFileReader File;
    if (File.Open(sFile) == NS_FAILURE)
    {
      nsLog::Error("Could not open for reading: '{0}'", sFile);
      return NS_FAILURE;
    }

    nsDynamicArray<nsUInt8> FileContent;

    nsUInt8 Temp[4024];
    nsUInt64 uiRead = File.ReadBytes(Temp, NS_ARRAY_SIZE(Temp));

    while (uiRead > 0)
    {
      FileContent.PushBackRange(nsArrayPtr<nsUInt8>(Temp, (nsUInt32)uiRead));

      uiRead = File.ReadBytes(Temp, NS_ARRAY_SIZE(Temp));
    }

    FileContent.PushBack(0);

    if (!nsUnicodeUtils::IsValidUtf8((const char*)&FileContent[0]))
    {
      nsLog::Error("The file \"{0}\" contains characters that are not valid Utf8. This often happens when you type special characters in "
                   "an editor that does not save the file in Utf8 encoding.",
        sFile);
      return NS_FAILURE;
    }

    out_sContents = (const char*)&FileContent[0];

    return NS_SUCCESS;
  }

  static nsResult FindIncludeFile(nsStringView sPath, CompilationUnitContext& inout_context, nsStringBuilder& out_sPath)
  {
    if (sPath.IsAbsolutePath())
    {
      out_sPath = sPath;
      out_sPath.MakeCleanPath();
      if (ExistsFileCache::ExistsFile(sPath))
      {
        return NS_SUCCESS;
      }
      else
      {
        return NS_FAILURE;
      }
    }

    for (auto& includeDir : inout_context.m_IncludeDirectories)
    {
      out_sPath = includeDir;
      out_sPath.AppendPath(sPath);
      out_sPath.MakeCleanPath();
      if (ExistsFileCache::ExistsFile(out_sPath))
      {
        return NS_SUCCESS;
      }
    }

    return NS_FAILURE;
  }

  bool IgnorePath(const nsStringBuilder& sBuilder)
  {
    for (auto& ignore : m_IgnorePatterns)
    {
      if (sBuilder.FindSubString(ignore))
      {
        return true;
      }
    }
    return false;
  }

  void ParseCompileCommandsJson()
  {
    nsFileReader reader;
    reader.Open(m_sCompileCommandsPath).AssertSuccess(); // TODO error handling

    CompileCommandsParser parser;
    parser.SetLogInterface(nsLog::GetThreadLocalLogSystem());
    parser.Initialize(reader);

    nsDynamicArray<nsStringView> commandParts;

    nsStringBuilder tmpPath;

    CompileCommandsParser::CompileCommand command;
    while (parser.GetNextCommand(command).Succeeded())
    {
      if (g_bVerbose)
      {
        nsLog::Info("file: {0}", command.file);
      }
      tmpPath = command.file;
      tmpPath.MakeCleanPath();

      if (IgnorePath(tmpPath))
      {
        continue;
      }

      if (tmpPath.GetFileExtension().Compare_NoCase("cpp") != 0)
      {
        continue;
      }

      auto& context = m_CompilationUnits[tmpPath];

      nsDynamicArray<nsString> includeFiles;

      command.command.Split(false, commandParts, " ");
      const nsUInt32 numParts = commandParts.GetCount();
      for (nsUInt32 i = 0; i < numParts; i++)
      {
        auto part = commandParts[i];
        if (part.Compare_NoCase("-isystem") == 0)
        {
          i++;
          part = commandParts[i];
          tmpPath = part;
          tmpPath.MakeCleanPath();

          if (!IgnorePath(tmpPath)) // TODO make command line parameter
          {
            if (g_bVerbose)
            {
              nsLog::Info(tmpPath);
            }
            context.m_IncludeDirectories.PushBack(tmpPath);
          }
        }
        else if (part.TrimWordStart("-include"))
        {
          tmpPath = part;
          tmpPath.MakeCleanPath();
          if (g_bVerbose)
          {
            nsLog::Info(tmpPath);
          }
          includeFiles.PushBack(tmpPath);
        }
        else if (part.TrimWordStart("-I"))
        {
          tmpPath = part;
          tmpPath.MakeCleanPath();
          if (!IgnorePath(tmpPath))
          {
            if (g_bVerbose)
            {
              nsLog::Info(tmpPath);
            }
            context.m_IncludeDirectories.PushBack(tmpPath);
          }
        }
      }

      for (auto& includeFile : includeFiles)
      {
        if (FindIncludeFile(includeFile.GetView(), context, tmpPath).Succeeded())
        {
          context.m_dependencies.Insert(tmpPath);
        }
        else
        {
          if (g_bVerbose)
          {
            nsLog::Warning("Could not find include file '{0}' specified on the command line in any include path", includeFile);
          }
        }
      }
    }
  }

  void ParseCompilationUnits()
  {
    struct CompUnit
    {
      nsStringView path;
      CompilationUnitContext* context;
    };
    nsDynamicArray<CompUnit> compilationUnits;
    compilationUnits.Reserve(m_CompilationUnits.GetCount());

    for (auto& compilationUnit : m_CompilationUnits)
    {
      compilationUnits.PushBack({compilationUnit.Key().GetView(), &compilationUnit.Value()});
    }

    nsTaskSystem::ParallelFor(
      compilationUnits.GetArrayPtr(), [this](nsArrayPtr<CompUnit> compUnits)
      {
        nsStringBuilder tmpPath;
        DependencyListType dependencies;
        for (auto& compUnit : compUnits)
        {
          nsStringView currentFile = compUnit.path;

          NS_LOG_BLOCK("CPP", currentFile);
          dependencies.Clear();
          FindDependencies(currentFile, dependencies);
          for (auto& dependency : dependencies)
          {
            if (!dependency.IsAbsolutePath())
            {
              if (FindIncludeFile(dependency.GetView(), *compUnit.context, tmpPath).Succeeded())
              {
                compUnit.context->m_dependencies.Insert(tmpPath);
              }
              else
              {
                if (g_bVerbose)
                {
                  nsLog::Warning("Warning dependency '{0}' of '{1}' not found", dependency, currentFile);
                }
              }
            }
          }
        } },
      "ParseCompilationUnit");
  }

  void ParseHeaderFiles()
  {
    nsStringBuilder tmpPath;
    nsDynamicArray<nsSharedPtr<ParseHeaderFileTask>> filesToCheckTasks;

    auto taskGroup = nsTaskSystem::CreateTaskGroup(nsTaskPriority::EarlyThisFrame);
    for (auto& compilationUnit : m_CompilationUnits)
    {
      for (auto& dependency : compilationUnit.Value().m_dependencies)
      {
        bool existed = false;
        if (auto& dependencies = m_HeaderDependencies.FindOrAdd(dependency.GetView(), &existed); !existed)
        {
          filesToCheckTasks.PushBack(NS_DEFAULT_NEW(ParseHeaderFileTask));
          filesToCheckTasks.PeekBack()->Initialize(dependency.GetView());
          nsTaskSystem::AddTaskToGroup(taskGroup, filesToCheckTasks.PeekBack());
        }
      }
    }

    nsTaskSystem::StartTaskGroup(taskGroup);
    nsTaskSystem::WaitForGroup(taskGroup);

    for (auto& task : filesToCheckTasks)
    {
      m_HeaderDependencies[task->GetPath()] = task->MoveOutDependencies();
    }
  }

  void CheckDependentFiles()
  {
    nsDynamicArray<nsSharedPtr<CollectDependenciesTask>> tasks;

    for (auto& compilationUnit : m_CompilationUnits)
    {
      tasks.PushBack(NS_DEFAULT_NEW(CollectDependenciesTask));
      tasks.PeekBack()->Initialize(compilationUnit.Key(), compilationUnit.Value(), *this);
    }

    const nsUInt32 totalNumTasks = tasks.GetCount();

    // First iteration
    {
      auto group = nsTaskSystem::CreateTaskGroup(nsTaskPriority::EarlyThisFrame);
      for (auto& task : tasks)
      {
        nsTaskSystem::AddTaskToGroup(group, task);
      }
      nsTaskSystem::StartTaskGroup(group);
      nsTaskSystem::WaitForGroup(group);
    }

    while (true)
    {
      for (nsUInt32 i = 0; i < tasks.GetCount();)
      {
        if (tasks[i]->HasWorkLeft())
        {
          tasks[i]->ScheduleRemainingWork();
          ++i;
        }
        else
        {
          tasks.RemoveAtAndSwap(i);
        }
      }

      if (tasks.GetCount() == 0) // If none of the tasks had work left, we are done
      {
        break;
      }

      nsLog::Info("Collecting dependencies. Remaining {0} of {1} total", tasks.GetCount(), totalNumTasks);

      nsTaskSystem::FinishFrameTasks(); // Wait for parsing tasks to finish before doing the next round of dependency collection

      auto group = nsTaskSystem::CreateTaskGroup(nsTaskPriority::EarlyThisFrame);
      for (auto& task : tasks)
      {
        nsTaskSystem::AddTaskToGroup(group, task);
      }
      nsTaskSystem::StartTaskGroup(group);
      nsTaskSystem::WaitForGroup(group);
    }
  }

  void WriteOutResults()
  {
    nsFileWriter FileOut;

    if (FileOut.Open(m_sOutputPath) == NS_FAILURE)
    {
      nsLog::Error("Could not open the file for writing: '{0}'", "results.json");
      return;
    }
    else
    {
      nsStringBuilder json;
      json.Append("{\n");
      json.Append(" \"files\" : [\n");

      auto processFile = [this, &json](CompilationUnitListType::Iterator& file)
      {
        json.Append("    {\n");
        json.AppendFormat("      \"name\" : \"{0}\",\n", file.Key());
        json.Append("      \"dependencies\" :\n");
        json.Append("        [\n");

        auto count = (*file).Value().m_dependencies.GetCount();
        if (count > 0)
        {
          count--;
          auto depIt = (*file).Value().m_dependencies.GetIterator();

          for (nsUInt32 i = 0; i < count; ++i, depIt.Next())
          {
            json.AppendFormat("       \"{0}\",\n", (*depIt).GetView());
          }
          json.AppendFormat("       \"{0}\"\n", (*depIt).GetView());
        }
        json.Append("        ]\n");
        json.Append("    }");
      };

      auto count = m_CompilationUnits.GetCount();
      if (count > 0)
      {
        count--;
        auto fileIt = m_CompilationUnits.GetIterator();
        for (nsUInt32 i = 0; i < count; ++i, fileIt.Next())
        {
          processFile(fileIt);
          json.Append(",\n");
        }
        processFile(fileIt);
        json.Append("\n");
      }
      json.Append("  ]\n");
      json.Append("}\n");

      FileOut.WriteBytes(json.GetData(), json.GetElementCount()).AssertSuccess();
    }
  }

  static void FindDependencies(nsStringView sCurrentFile, DependencyListType& inout_dependencies)
  {
    nsStringBuilder fileContents;
    ReadEntireFile(sCurrentFile, fileContents).IgnoreResult();

    auto fileDir = sCurrentFile.GetFileDirectory();

    nsTokenizer tokenizer;
    auto dataView = fileContents.GetView();
    auto start = dataView.GetStartPointer();
    auto elementCount = dataView.GetElementCount();
    if (elementCount >= 3 && nsUnicodeUtils::SkipUtf8Bom(start))
    {
      elementCount -= 3;
    }
    tokenizer.Tokenize(nsArrayPtr<const nsUInt8>(reinterpret_cast<const nsUInt8*>(start), elementCount), nsLog::GetThreadLocalLogSystem());

    nsStringView hash("#");
    nsStringView include("include");
    nsStringView openAngleBracket("<");
    nsStringView closeAngleBracket(">");

    auto tokens = tokenizer.GetTokens();
    const auto numTokens = tokens.GetCount();
    for (nsUInt32 i = 0; i < numTokens; i++)
    {
      auto curToken = tokens[i];
      while (curToken.m_iType == nsTokenType::Whitespace)
      {
        curToken = tokens[++i];
      }
      if (curToken.m_iType == nsTokenType::NonIdentifier && curToken.m_DataView == hash)
      {
        do
        {
          curToken = tokens[++i];
        } while (curToken.m_iType == nsTokenType::Whitespace);

        if (curToken.m_iType == nsTokenType::Identifier && curToken.m_DataView == include)
        {
          auto includeToken = curToken;
          do
          {
            curToken = tokens[++i];
          } while (curToken.m_iType == nsTokenType::Whitespace);

          if (curToken.m_iType == nsTokenType::String1)
          {
            // #include "bla"
            nsStringBuilder absIncludePath;
            nsStringBuilder relativePath;
            relativePath = curToken.m_DataView;
            relativePath.Trim("\"");
            relativePath.MakeCleanPath();
            absIncludePath = fileDir;
            absIncludePath.AppendPath(relativePath);

            if (!ExistsFileCache::ExistsFile(absIncludePath))
            {
              inout_dependencies.Insert(relativePath);
            }
            else
            {
              inout_dependencies.Insert(absIncludePath);
            }
          }
          else if (curToken.m_iType == nsTokenType::NonIdentifier && curToken.m_DataView == openAngleBracket)
          {
            // #include <bla>
            bool error = false;
            auto startToken = curToken;
            do
            {
              curToken = tokens[++i];
              if (curToken.m_iType == nsTokenType::Newline)
              {
                nsLog::Error("Non-terminated '<' in #include {0} line {1}", sCurrentFile, includeToken.m_uiLine);
                error = true;
                break;
              }
            } while (curToken.m_iType != nsTokenType::NonIdentifier || curToken.m_DataView != closeAngleBracket);

            if (error)
            {
              // in case of error skip the malformed line in hopes that we can recover from the error.
              do
              {
                curToken = tokens[++i];
              } while (curToken.m_iType != nsTokenType::Newline);
            }
            else
            {
              nsStringBuilder includePath;
              includePath = nsStringView(startToken.m_DataView.GetEndPointer(), curToken.m_DataView.GetStartPointer());
              includePath.MakeCleanPath();
              inout_dependencies.Insert(includePath);
            }
          }
          else
          {
            // error
            nsLog::Error("Can not parse #include statement in {0} line {1}", sCurrentFile, includeToken.m_uiLine);
          }
        }
        else
        {
          while (curToken.m_iType != nsTokenType::Newline && curToken.m_iType != nsTokenType::EndOfFile)
          {
            curToken = tokens[++i];
          }
        }
      }
      else
      {
        while (curToken.m_iType != nsTokenType::Newline && curToken.m_iType != nsTokenType::EndOfFile)
        {
          curToken = tokens[++i];
        }
      }
    }
  }

  virtual nsApplication::Execution Run() override
  {
    // something basic has gone wrong
    if (m_bHadSeriousWarnings || m_bHadErrors)
      return nsApplication::Execution::Quit;

    auto start = nsTimestamp::CurrentTimestamp();

    if (g_bVerbose)
    {
      nsLog::Info("Parse compile commands json");
    }
    ParseCompileCommandsJson();

    auto parseJsonEnd = nsTimestamp::CurrentTimestamp();

    if (g_bVerbose)
    {
      nsLog::Info("Parse compilation units");
    }
    ParseCompilationUnits();

    auto parseCompilationUnitsEnd = nsTimestamp::CurrentTimestamp();

    if (g_bVerbose)
    {
      nsLog::Info("Parse header files");
    }
    ParseHeaderFiles();

    auto parseHeaderFilesEnd = nsTimestamp::CurrentTimestamp();

    if (g_bVerbose)
    {
      nsLog::Info("Build dependencies");
    }
    CheckDependentFiles();

    auto checkDependendtFilesEnd = nsTimestamp::CurrentTimestamp();

    if (g_bVerbose)
    {
      nsLog::Info("Write out results");
    }
    WriteOutResults();

    auto writeOutResultsEnd = nsTimestamp::CurrentTimestamp();

    nsLog::Info("Time to parse compile commands json: {0}s", (parseJsonEnd - start).AsFloatInSeconds());
    nsLog::Info("Time to parse compilation units: {0}s", (parseCompilationUnitsEnd - parseJsonEnd).AsFloatInSeconds());
    nsLog::Info("Time to parse header files: {0}s", (parseHeaderFilesEnd - parseCompilationUnitsEnd).AsFloatInSeconds());
    nsLog::Info("Time to build dependencies: {0}s", (checkDependendtFilesEnd - parseHeaderFilesEnd).AsFloatInSeconds());
    nsLog::Info("Time to write out results: {0}s", (writeOutResultsEnd - checkDependendtFilesEnd).AsFloatInSeconds());
    nsLog::Info("Total time taken: {0}s", (writeOutResultsEnd - start).AsFloatInSeconds());

    return nsApplication::Execution::Quit;
  }
};

void ParseHeaderFileTask::Execute()
{
  nsDependencyAnalysisApp::FindDependencies(m_sPath, m_Dependencies);
}

void CollectDependenciesTask::Execute()
{
  NS_ASSERT_DEBUG(m_pContext != nullptr && m_pApp != nullptr, "Task was not initialized properly");

  auto& compilationUnitDependencies = m_pContext->m_dependencies;

  nsDynamicArray<nsString> filesToCheck;
  if (m_LeftoverFiles.GetCount() > 0)
  {
    filesToCheck.Swap(m_LeftoverFiles);
    m_ParseTasks.Clear();
  }
  else
  {
    for (auto& include : compilationUnitDependencies)
    {
      filesToCheck.PushBack(include);
    }
  }

  nsHashSet<nsString> seenFiles;

  while (!filesToCheck.IsEmpty())
  {
    auto include = std::move(filesToCheck.PeekBack());
    filesToCheck.PopBack();

    if (seenFiles.Insert(include))
    {
      continue;
    }

    bool alreadyExisted = false;

    DependencyListType* headerDependencies = nullptr;
    if (!m_pApp->m_HeaderDependencies.TryGetValue(include.GetView(), headerDependencies))
    {
      {
        NS_LOCK(m_pApp->m_HeaderParsingScheduledMutex);
        if (!m_pApp->m_HeaderParsingScheduled.Insert(include.GetView()))
        {
          if (m_ParseTasks.GetCount() == 0)
          {
            m_ParseTaskGroup = nsTaskSystem::CreateTaskGroup(nsTaskPriority::EarlyThisFrame, nsMakeDelegate(&CollectDependenciesTask::OnParsingFinished, this));
          }
          nsSharedPtr<ParseHeaderFileTask> task = NS_DEFAULT_NEW(ParseHeaderFileTask);
          task->Initialize(include);
          nsTaskSystem::AddTaskToGroup(m_ParseTaskGroup, task);
          m_ParseTasks.PushBack(std::move(task));
        }
      }
    }
    else
    {
      nsStringBuilder tmpPath;
      for (auto& dependency : *headerDependencies)
      {
        if (m_pApp->FindIncludeFile(dependency.GetView(), *m_pContext, tmpPath).Succeeded())
        {
          if (!compilationUnitDependencies.Contains(tmpPath.GetView()))
          {
            compilationUnitDependencies.Insert(tmpPath);
            filesToCheck.PushBack(tmpPath);
          }
        }
        else
        {
          if (g_bVerbose)
          {
            nsLog::Warning("Failed to find dependency '{0}' of compilation unit '{1}'", dependency, m_sPath);
          }
        }
      }
    }
  }
}

void CollectDependenciesTask::ScheduleRemainingWork()
{
  if (m_ParseTasks.GetCount() > 0)
  {
    nsTaskSystem::StartTaskGroup(m_ParseTaskGroup);
  }
}

void CollectDependenciesTask::OnParsingFinished(nsTaskGroupID taskGroupId)
{
  NS_LOCK(m_pApp->m_HeaderDependenciesMutex);
  for (auto& task : m_ParseTasks)
  {
    bool alreadyExisted = false;
    auto& deps = m_pApp->m_HeaderDependencies.FindOrAdd(task->GetPath(), &alreadyExisted);
    if (!alreadyExisted)
    {
      deps = task->MoveOutDependencies();
    }
  }
}

NS_CONSOLEAPP_ENTRY_POINT(nsDependencyAnalysisApp);
